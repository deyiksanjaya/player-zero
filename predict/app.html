<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Player Zero by Heri Sanjaya</title>

    <!-- Meta Tags PWA -->
    <meta name="theme-color" content="#000000"/>
    <link rel="manifest" href="./manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Prediction">
    <link rel="apple-touch-icon" href="/icons/icon-180x180.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700&display=swap" rel="stylesheet">

    <style>
        html, body {
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        body {
            font-family: 'Poppins', sans-serif;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* --- TTT Layout --- */
        #tictactoe-game {
            position: relative;
            width: 100vw; 
            height: 100vw; 
            max-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        #slide-wrapper {
            height: 100%;
            display: flex;
            gap: 20px; 
        }
        .slide-container {
            height: 100%;
            width: 100vw;
            flex-shrink: 0;
            box-sizing: border-box;
            background-color: white;
            color: black;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease-in-out;
        }
        #peek-board-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 60; /* Ensure it's on top */
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        #peek-board-container.visible { opacity: 1; }
        #prediction-slide.peeking { opacity: 0.1; }
        #board-image { cursor: pointer; }

        /* --- RPS Layout & Visual Cues --- */
        .rps-wrapper {
            position: relative; 
            border-radius: 0.5rem;
            transition: transform 0.2s ease;
            cursor: pointer;
        }
        .rps-wrapper:hover {
             transform: scale(1.05);
        }
        /* Style for the 1-pixel white dot */
        .rps-wrapper.has-dot::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1px;
            height: 1px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 0 2px 1px rgba(255, 255, 255, 0.7);
        }
        #rps-image-container img {
             transition: transform 0.2s ease;
        }
        .is-authenticating {
            pointer-events: none;
            cursor: wait;
        }
        
        .scrollable-input {
            white-space: nowrap;
            overflow-x: auto;
        }
        /* Hide scrollbar for cleaner look */
        .scrollable-input::-webkit-scrollbar {
            display: none;
        }
        .scrollable-input {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
    </style>
</head>
<body class="w-screen h-screen flex justify-center items-center">

    <!-- Settings Trigger (Remains invisible for the magic method) -->
    <div id="settings-trigger" class="absolute top-0 right-0 h-20 w-20 z-50 cursor-pointer"></div>

    <!-- Settings Panel (Modal) -->
    <div id="settings-panel" class="hidden fixed inset-0 z-40 bg-black/60 backdrop-blur-md flex items-center justify-center p-4">
        <div class="bg-gray-800 border border-gray-700 text-white rounded-xl shadow-lg w-full max-w-sm p-6 space-y-6">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-bold">Settings</h2>
                <button id="close-settings-btn" aria-label="Close Settings" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>

            <div>
                <label for="game-mode-select" class="font-medium">Game Mode</label>
                <select id="game-mode-select" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                    <option value="TicTacToe">Tic-Tac-Toe</option>
                    <option value="RockPaperScissors">Rock-Paper-Scissors</option>
                </select>
            </div>

            <!-- Tic-Tac-Toe Settings -->
            <div id="tictactoe-settings" class="space-y-4">
                <div>
                    <label class="font-medium">Mode</label>
                    <div class="mt-2 grid grid-cols-3 gap-2 text-sm">
                        <button id="mode-online-btn" class="p-2 rounded-md transition-colors" aria-label="Select Online Mode">Online</button>
                        <button id="mode-manual-btn" class="p-2 rounded-md transition-colors" aria-label="Select Manual Mode">Manual</button>
                        <button id="mode-direct-shortcut-btn" class="p-2 rounded-md transition-colors" aria-label="Select Direct Shortcut Output">Shortcut</button>
                    </div>
                </div>
                 <div id="shortcut-input-mode-container" class="hidden pl-4 mt-2 space-y-2 border-l-2 border-gray-600">
                    <label class="font-medium text-sm text-gray-400">Shortcut Input</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="shortcut-mode-auto-btn" class="p-2 rounded-md transition-colors text-sm" aria-label="Select Auto Input">Auto</button>
                        <button id="shortcut-mode-swipe-btn" class="p-2 rounded-md transition-colors text-sm" aria-label="Select Swipe Input">Swipe</button>
                    </div>
                </div>
                <div>
                    <label for="shortcut-name-input" class="font-medium">Shortcut Name (iOS)</label>
                    <input type="text" id="shortcut-name-input" placeholder="E.g., Open Camera" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                </div>
                <div id="ttt-text-settings-container" class="space-y-4">
                    <div>
                        <label for="prediction-text-input" class="font-medium">Prediction Text</label>
                        <input type="text" id="prediction-text-input" placeholder="e.g., I predict..." class="scrollable-input w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md">
                    </div>
                    <div>
                        <label for="winner-result-text-input" class="font-medium">Winner Result Text ($winner)</label>
                        <input type="text" id="winner-result-text-input"
                               placeholder="e.g., $winner takes the game!"
                               class="scrollable-input w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md">
                    </div>
                     <div>
                        <label for="draw-result-text-input" class="font-medium">Draw Result Text</label>
                        <input type="text" id="draw-result-text-input" placeholder="e.g., A classic draw." class="scrollable-input w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md">
                    </div>
                </div>
            </div>

            <!-- Rock-Paper-Scissors Settings -->
            <div id="rps-settings" class="hidden space-y-4">
                 <div>
                    <label class="font-medium">Play Style</label>
                     <div class="mt-2 grid grid-cols-3 gap-2 text-sm">
                        <button id="rps-mode-magician-btn" class="p-2 rounded-md transition-colors">Magician first</button>
                        <button id="rps-mode-spectator-btn" class="p-2 rounded-md transition-colors">Spectator first</button>
                        <button id="rps-mode-mirroring-btn" class="p-2 rounded-md transition-colors">Mirroring</button>
                    </div>
                 </div>
                 <div id="rps-rounds-container">
                    <label for="rps-rounds-input" class="font-medium">Number of Rounds (1-5)</label>
                    <input type="number" id="rps-rounds-input" min="1" max="5" value="5" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                </div>
                 <div id="rps-targets-container" class="space-y-4">
                     <div>
                        <label for="rps-wins-input" class="font-medium">Target Wins</label>
                        <input type="number" id="rps-wins-input" min="0" max="5" value="0" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                    </div>
                     <div>
                        <label for="rps-loses-input" class="font-medium">Target Losses</label>
                        <input type="number" id="rps-loses-input" min="0" max="5" value="0" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                    </div>
                     <div>
                        <label for="rps-draws-input" class="font-medium">Target Draws</label>
                        <input type="number" id="rps-draws-input" min="0" max="5" value="0" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
                    </div>
                 </div>
            </div>

            <div class="mt-6 flex justify-end">
                <button id="save-settings-btn" class="px-5 py-2 bg-blue-600 font-semibold rounded-lg hover:bg-blue-700 transition-colors">Save & Close</button>
            </div>
        </div>
    </div>

    <!-- Tic-Tac-Toe Game Container -->
    <main id="tictactoe-game">
        <div id="slide-wrapper">
            <div id="prediction-slide" class="slide-container text-3xl font-bold text-center">
                <span id="prediction-text-display">my prediction..</span>
            </div>
            <div class="slide-container text-2xl font-semibold text-center">
                <h2 id="result-text" class="px-8"></h2>
            </div>
            <div class="slide-container">
                <img id="board-image" alt="Final Game Board" class="w-full h-full object-contain">
            </div>
        </div>
    </main>

    <!-- This container is now independent -->
    <div id="peek-board-container">
        <canvas id="peek-canvas"></canvas>
    </div>

    <!-- Direct Shortcut Mode Display -->
    <div id="direct-shortcut-mode-display" class="hidden w-full h-full flex items-center justify-center cursor-pointer p-4">
        <p id="direct-shortcut-status-text" class="text-2xl font-semibold text-center text-gray-400"></p>
    </div>

    <!-- Rock-Paper-Scissors Game Container -->
    <div id="rps-game" class="hidden flex flex-col items-center justify-center p-6">
        <div id="rps-image-container" class="flex flex-col flex-wrap justify-center gap-8">
            <div id="rock-wrapper" class="rps-wrapper">
                <img id="rock" src="/icons/rps/rock.png" alt="Rock" class="w-48 h-48 md:w-64 md:h-64 rounded-lg object-cover invert shadow-lg" onerror="this.onerror=null;this.src='https://placehold.co/256/f1f5f9/334155?text=Rock';">
            </div>
            <div id="paper-wrapper" class="rps-wrapper">
                <img id="paper" src="/icons/rps/paper.png" alt="Paper" class="w-48 h-48 md:w-64 md:h-64 rounded-lg object-cover invert shadow-lg" onerror="this.onerror=null;this.src='https://placehold.co/256/f1f5f9/334155?text=Paper';">
            </div>
            <div id="scissors-wrapper" class="rps-wrapper">
                <img id="scissors" src="/icons/rps/scissors.png" alt="Scissors" class="w-48 h-48 md:w-64 md:h-64 rounded-lg object-cover invert shadow-lg" onerror="this.onerror=null;this.src='https://placehold.co/256/f1f5f9/334155?text=Scissors';">
            </div>
        </div>
    </div>
    
    <!-- Fullscreen Overlay for RPS -->
    <div id="rps-fullscreen-overlay" class="hidden fixed inset-0 bg-black flex items-center justify-center z-50 p-4">
        <button id="rps-close-fullscreen" class="absolute top-4 right-6 text-gray-200 text-5xl font-bold hover:text-white shadow-lg">&times;</button>
        <img id="rps-fullscreen-image" src="" alt="Fullscreen Choice" class="w-[512px] h-[512px] object-contain rounded-lg invert">
    </div>


    <!-- PWA Update Notification -->
    <div id="update-notification" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 bg-green-600 text-white px-5 py-3 rounded-lg shadow-lg">
        Application updated. Ready for offline use.
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue, set, serverTimestamp as rtdbServerTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyDsnZdGtP-tY1_vstQOidbM3tS-UktY45Y",
            authDomain: "player-zer0.firebaseapp.com",
            databaseURL: "https://player-zer0-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "player-zer0",
            storageBucket: "player-zer0.appspot.com",
            messagingSenderId: "1009636905003",
            appId: "1:1009636905003:web:f3fafd5f5a693440769a6e"
        };
        
        // --- Constants ---
        const WINNING_COMBINATIONS = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];
        const SWIPE_THRESHOLD = 50;
        const DOUBLE_TAP_TIMEOUT = 300;
        const HOLD_TO_PEEK_DELAY = 250;
        const SLIDE_GAP = 20;
        const OUTPUT_CANVAS_SIZE = 1024; // High resolution for sharp output
        const CLASS_NAMES = {
            HIDDEN: 'hidden',
            VISIBLE: 'visible',
            PEEKING: 'peeking',
            ACTIVE_BUTTON: 'bg-blue-600',
            INACTIVE_BUTTON: 'bg-gray-700',
            HAS_DOT: 'has-dot', 
        };

        // --- DOM Elements ---
        const dom = {
            settingsTrigger: document.getElementById('settings-trigger'),
            settingsPanel: document.getElementById('settings-panel'),
            saveSettingsBtn: document.getElementById('save-settings-btn'),
            closeSettingsBtn: document.getElementById('close-settings-btn'),
            updateNotification: document.getElementById('update-notification'),
            gameModeSelect: document.getElementById('game-mode-select'),
            tttGame: document.getElementById('tictactoe-game'),
            sliderStage: document.getElementById('tictactoe-game'), 
            slideWrapper: document.getElementById('slide-wrapper'),
            predictionSlide: document.getElementById('prediction-slide'),
            peekBoardContainer: document.getElementById('peek-board-container'),
            peekCanvas: document.getElementById('peek-canvas'),
            resultText: document.getElementById('result-text'),
            boardImage: document.getElementById('board-image'),
            tttSettings: document.getElementById('tictactoe-settings'),
            modeOnlineBtn: document.getElementById('mode-online-btn'),
            modeManualBtn: document.getElementById('mode-manual-btn'),
            modeDirectShortcutBtn: document.getElementById('mode-direct-shortcut-btn'),
            shortcutInputModeContainer: document.getElementById('shortcut-input-mode-container'),
            shortcutModeAutoBtn: document.getElementById('shortcut-mode-auto-btn'),
            shortcutModeSwipeBtn: document.getElementById('shortcut-mode-swipe-btn'),
            shortcutNameInput: document.getElementById('shortcut-name-input'),
            tttTextSettingsContainer: document.getElementById('ttt-text-settings-container'),
            predictionTextInput: document.getElementById('prediction-text-input'),
            winnerResultTextInput: document.getElementById('winner-result-text-input'),
            drawResultTextInput: document.getElementById('draw-result-text-input'),
            predictionTextDisplay: document.getElementById('prediction-text-display'),
            directShortcutModeDisplay: document.getElementById('direct-shortcut-mode-display'),
            directShortcutStatusText: document.getElementById('direct-shortcut-status-text'),
            rpsGame: document.getElementById('rps-game'),
            rpsImageContainer: document.getElementById('rps-image-container'),
            rockWrapper: document.getElementById('rock-wrapper'),
            paperWrapper: document.getElementById('paper-wrapper'),
            scissorsWrapper: document.getElementById('scissors-wrapper'),
            rockImg: document.getElementById('rock'),
            paperImg: document.getElementById('paper'),
            scissorsImg: document.getElementById('scissors'),
            rpsFullscreenOverlay: document.getElementById('rps-fullscreen-overlay'),
            rpsFullscreenImage: document.getElementById('rps-fullscreen-image'),
            rpsCloseFullscreenBtn: document.getElementById('rps-close-fullscreen'),
            rpsSettings: document.getElementById('rps-settings'),
            rpsModeMagicianBtn: document.getElementById('rps-mode-magician-btn'),
            rpsModeSpectatorBtn: document.getElementById('rps-mode-spectator-btn'),
            rpsModeMirroringBtn: document.getElementById('rps-mode-mirroring-btn'),
            rpsRoundsInput: document.getElementById('rps-rounds-input'),
            rpsTargetsContainer: document.getElementById('rps-targets-container'),
            rpsWinsInput: document.getElementById('rps-wins-input'),
            rpsLosesInput: document.getElementById('rps-loses-input'),
            rpsDrawsInput: document.getElementById('rps-draws-input'),
        };

        // --- Application State ---
        let state = {
            settings: { 
                gameMode: 'TicTacToe',
                tttMode: 'online', 
                tttShortcutInputMode: 'auto',
                tttShortcutName: '',
                tttPredictionText: 'my prediction..',
                tttWinnerResultText: 'I knew... $winner would win!',
                tttDrawText: 'I knew... it would be a draw!',
                rpsPlayMode: 'magicianFirst', 
                rpsRounds: 5,
                rpsWins: 0,
                rpsLoses: 0,
                rpsDraws: 0,
            },
            firebaseUnsubscribe: null,
            isInitialRpsLoad: true,
            boardData: Array(9).fill(null),
            currentPlayer: 'X',
            gameFinished: false,
            currentSlide: 0,
            swipeGroup: null,
            lastTapTime: 0,
            touchStart: { x: 0, y: 0 },
            slideWidth: 0,
            isDragging: false,
            isPeeking: false,
            peekTimer: null,
            initialTranslate: 0,
            rpsGamePlan: [],
            rpsCurrentRound: 0,
            rpsCorrectChoiceForSpectator: null,
            isRpsFreePlayActive: true, 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        
        const outputCanvas = document.createElement('canvas');
        outputCanvas.width = OUTPUT_CANVAS_SIZE;
        outputCanvas.height = OUTPUT_CANVAS_SIZE;

        // --- Helper Functions ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => { clearTimeout(timeout); func(...args); };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- MAIN GAME MODE SWITCHER ---
        function switchGameMode(mode, isInitialLoad = false) {
            state.settings.gameMode = mode;
            if (state.firebaseUnsubscribe) { state.firebaseUnsubscribe(); state.firebaseUnsubscribe = null; }
            
            const isTTT = mode === 'TicTacToe';
            dom.tttSettings.classList.toggle(CLASS_NAMES.HIDDEN, !isTTT);
            dom.rpsSettings.classList.toggle(CLASS_NAMES.HIDDEN, isTTT);

            if (isTTT) {
                dom.rpsGame.classList.add(CLASS_NAMES.HIDDEN);
                initTicTacToe(isInitialLoad);
            } else {
                dom.tttGame.classList.add(CLASS_NAMES.HIDDEN);
                dom.directShortcutModeDisplay.classList.add(CLASS_NAMES.HIDDEN);
                dom.rpsGame.classList.remove(CLASS_NAMES.HIDDEN);
                initRockPaperScissors(isInitialLoad);
            }
        }
        
        // --- TIC-TAC-TOE LOGIC ---
        function initTicTacToe(isInitialLoad) { 
            updateSlideDimensions(); 
            toggleTttMode(state.settings.tttMode, isInitialLoad); 
        }

        function updateSlideDimensions() {
            state.slideWidth = dom.sliderStage.getBoundingClientRect().width;
            const slides = dom.slideWrapper.querySelectorAll('.slide-container');
            slides.forEach(slide => {
                slide.style.width = `${state.slideWidth}px`;
            });
            dom.peekCanvas.width = state.slideWidth;
            dom.peekCanvas.height = state.slideWidth;
            animateToSlide(state.currentSlide, 0);
        }

        function animateToSlide(slideIndex, duration = 400) {
            state.currentSlide = Math.max(0, Math.min(slideIndex, 2));
            const totalTranslation = (state.slideWidth * state.currentSlide) + (SLIDE_GAP * state.currentSlide);
            dom.slideWrapper.style.transition = `transform ${duration}ms ease-in-out`;
            dom.slideWrapper.style.transform = `translateX(-${totalTranslation}px)`;
        }

        function drawOnCanvas(canvas, boardData, winningCombination = null) {
            const size = canvas.width;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, size, size);
            const cellSize = size / 3;
            ctx.strokeStyle = '#CBD5E1'; ctx.lineWidth = size * 0.02; ctx.beginPath();
            for (let i = 1; i < 3; i++) {
                ctx.moveTo(i * cellSize, 0); ctx.lineTo(i * cellSize, size);
                ctx.moveTo(0, i * cellSize); ctx.lineTo(size, i * cellSize);
            }
            ctx.stroke();
            ctx.font = `bold ${cellSize * 0.7}px Poppins`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            boardData.forEach((value, index) => {
                if (!value) return;
                const row = Math.floor(index / 3), col = index % 3;
                const x = col * cellSize + cellSize / 2, y = row * cellSize + cellSize / 2;
                ctx.fillStyle = value === 'X' ? '#EF4444' : '#3B82F6';
                ctx.fillText(value, x, y);
            });

            if (winningCombination) {
                const winner = boardData[winningCombination[0]];
                ctx.strokeStyle = winner === 'X' ? '#EF4444' : '#3B82F6';
                ctx.lineWidth = size * 0.03; 
                ctx.lineCap = 'round';

                const getCoords = (index) => {
                    const row = Math.floor(index / 3);
                    const col = index % 3;
                    return {
                        x: col * cellSize + cellSize / 2,
                        y: row * cellSize + cellSize / 2,
                    };
                };

                const startCoords = getCoords(winningCombination[0]);
                const endCoords = getCoords(winningCombination[2]);
                
                ctx.beginPath();
                ctx.moveTo(startCoords.x, startCoords.y);
                ctx.lineTo(endCoords.x, endCoords.y);
                ctx.stroke();
            }
        }

        function checkWinner(board) {
            for (const combination of WINNING_COMBINATIONS) {
                const [a, b, c] = combination;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return { winner: board[a], combination };
                }
            }
            return null;
        }

        function handlePostMove() {
            const winnerInfo = checkWinner(state.boardData);
            const isFull = state.boardData.every(cell => cell !== null);
            if (winnerInfo || isFull) {
                state.gameFinished = true;
                drawOnCanvas(outputCanvas, state.boardData, winnerInfo ? winnerInfo.combination : null);
                dom.boardImage.src = outputCanvas.toDataURL('image/png');

                if (state.settings.tttMode === 'directShortcut') {
                    dom.directShortcutStatusText.textContent = 'Data ready. Tap to run shortcut.';
                } else {
                    let message;
                    if (winnerInfo) {
                        message = state.settings.tttWinnerResultText.replace('$winner', winnerInfo.winner);
                    } else {
                        message = state.settings.tttDrawText;
                    }
                    dom.resultText.textContent = message;
                }
            } else {
                state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
            }
        }
        
        function resetTttGame() {
            state.boardData.fill(null);
            state.currentPlayer = 'X';
            state.gameFinished = false;
            state.swipeGroup = null;
            if (state.settings.tttMode === 'directShortcut') {
                if (state.settings.tttShortcutInputMode === 'swipe') {
                    dom.directShortcutStatusText.textContent = 'Input moves with swipes.';
                } else {
                    dom.directShortcutStatusText.textContent = 'Waiting for game data...';
                }
            } else {
                dom.resultText.textContent = '';
                dom.boardImage.src = '';
                animateToSlide(0, 0);
                updatePredictionTextUI();
            }

            if (state.settings.tttMode === 'online' || (state.settings.tttMode === 'directShortcut' && state.settings.tttShortcutInputMode === 'auto')) {
                 const gameRef = ref(db, 'magic-game-state');
                 set(gameRef, { board: state.boardData, timestamp: rtdbServerTimestamp() });
            }
        }

        function startPeeking() {
            const isManualMode = state.settings.tttMode === 'manual';
            const isShortcutSwipeMode = state.settings.tttMode === 'directShortcut' && state.settings.tttShortcutInputMode === 'swipe';

            if (state.gameFinished || !(isManualMode || isShortcutSwipeMode)) return;

            state.isPeeking = true;
            drawOnCanvas(dom.peekCanvas, state.boardData);
            dom.peekBoardContainer.classList.add(CLASS_NAMES.VISIBLE);

            if (isManualMode) {
                dom.predictionSlide.classList.add(CLASS_NAMES.PEEKING);
            }
        }

        function stopPeeking() {
            if (!state.isPeeking) return;
            state.isPeeking = false;
            dom.peekBoardContainer.classList.remove(CLASS_NAMES.VISIBLE);

            if (state.settings.tttMode === 'manual') {
                dom.predictionSlide.classList.remove(CLASS_NAMES.PEEKING);
            }
        }

        function handleManualGesture(deltaX, deltaY) {
            if (state.gameFinished) return;
            if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) return;
            const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);
            const direction = isHorizontal ? (deltaX > 0 ? 'right' : 'left') : (deltaY > 0 ? 'down' : 'up');
            const gestureMap = {
                'col-left': { 'up': 0, 'middle': 3, 'down': 6 },
                'col-right': { 'up': 2, 'middle': 5, 'down': 8 },
                'row-top': { 'left': 0, 'middle': 1, 'right': 2 },
                'row-bottom': { 'left': 6, 'middle': 7, 'right': 8 }
            };
            if (!state.swipeGroup) {
                if (direction === 'up') state.swipeGroup = 'row-top';
                else if (direction === 'down') state.swipeGroup = 'row-bottom';
                else if (direction === 'left') state.swipeGroup = 'col-left';
                else if (direction === 'right') state.swipeGroup = 'col-right';
            } else {
                let cellIndex = -1;
                let secondDirection = 'middle';
                if (state.swipeGroup.startsWith('col')) {
                    if (direction === 'up') secondDirection = 'up';
                    else if (direction === 'down') secondDirection = 'down';
                } else {
                    if (direction === 'left') secondDirection = 'left';
                    else if (direction === 'right') secondDirection = 'right';
                }
                cellIndex = gestureMap[state.swipeGroup]?.[secondDirection];
                if (cellIndex !== undefined && state.boardData[cellIndex] === null) {
                    state.boardData[cellIndex] = state.currentPlayer;
                    handlePostMove();
                }
                state.swipeGroup = null;
            }
        }

        async function copyBase64ToClipboard(imageElement) {
            const base64Data = imageElement.src;
            if (!base64Data || !base64Data.startsWith('data:image/png')) {
                return false;
            }
            try {
                await navigator.clipboard.writeText(base64Data);
                return true;
            } catch (err) {
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = base64Data;
                    document.body.appendChild(textArea);
                    textArea.select();
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return successful;
                } catch (fallbackErr) {
                    return false;
                }
            }
        }
        
        function handleTouchStart(e) {
            if (state.settings.gameMode !== 'TicTacToe') return;
            const target = e.currentTarget;
            if (target === dom.sliderStage && state.settings.tttMode !== 'directShortcut') {
                 e.preventDefault();
                 state.touchStart.x = e.touches[0].clientX;
                 state.touchStart.y = e.touches[0].clientY;
                 state.isDragging = false;
                 clearTimeout(state.peekTimer);
                 state.peekTimer = setTimeout(startPeeking, HOLD_TO_PEEK_DELAY);
                 if (state.gameFinished) {
                    dom.slideWrapper.style.transition = 'none';
                    const totalTranslation = (state.slideWidth * state.currentSlide) + (SLIDE_GAP * state.currentSlide);
                    state.initialTranslate = -totalTranslation;
                 }
                 const now = Date.now();
                 if (now - state.lastTapTime <= DOUBLE_TAP_TIMEOUT) {
                    handleDoubleTap();
                    state.lastTapTime = 0;
                 } else {
                    state.lastTapTime = now;
                 }
            } else if (target === dom.directShortcutModeDisplay) {
                e.preventDefault();
                state.touchStart.x = e.touches[0].clientX;
                state.touchStart.y = e.touches[0].clientY;
                state.isDragging = false;
                if (state.settings.tttShortcutInputMode === 'swipe') {
                    clearTimeout(state.peekTimer);
                    state.peekTimer = setTimeout(startPeeking, HOLD_TO_PEEK_DELAY);
                }
            }
        }

        function handleTouchMove(e) {
             if (state.settings.gameMode !== 'TicTacToe') return;
             const target = e.currentTarget;
             const deltaX = e.touches[0].clientX - state.touchStart.x;
             const deltaY = e.touches[0].clientY - state.touchStart.y;
             if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) state.isDragging = true;

             if (target === dom.sliderStage && state.settings.tttMode !== 'directShortcut') {
                e.preventDefault();
                clearTimeout(state.peekTimer);
                if (state.isPeeking) stopPeeking();
                if (state.gameFinished && state.isDragging) {
                    dom.slideWrapper.style.transform = `translateX(${state.initialTranslate + deltaX}px)`;
                }
            } else if (target === dom.directShortcutModeDisplay) {
                 e.preventDefault();
                 clearTimeout(state.peekTimer);
                 if (state.isPeeking) stopPeeking();
            }
        }

        async function handleTouchEnd(e) {
            if (state.settings.gameMode !== 'TicTacToe') return;
            const target = e.currentTarget;

            clearTimeout(state.peekTimer);
            if (state.isPeeking) {
                stopPeeking();
                state.isDragging = false;
                return;
            }

            if (target === dom.sliderStage && state.settings.tttMode !== 'directShortcut') {
                const deltaX = e.changedTouches[0].clientX - state.touchStart.x;
                if (state.gameFinished) {
                    if (state.isDragging) {
                        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                            if (deltaX < 0) animateToSlide(state.currentSlide + 1);
                            else animateToSlide(state.currentSlide - 1);
                        } else {
                            animateToSlide(state.currentSlide);
                        }
                    } else if (e.target === dom.boardImage) {
                        await handleBoardClick();
                    }
                } else if (state.settings.tttMode === 'manual' && state.isDragging) {
                    const deltaY = e.changedTouches[0].clientY - state.touchStart.y;
                    handleManualGesture(deltaX, deltaY);
                }
            } else if (target === dom.directShortcutModeDisplay) {
                 if (state.isDragging && state.settings.tttShortcutInputMode === 'swipe') {
                    const deltaX = e.changedTouches[0].clientX - state.touchStart.x;
                    const deltaY = e.changedTouches[0].clientY - state.touchStart.y;
                    handleManualGesture(deltaX, deltaY);
                 } else if (!state.isDragging && state.gameFinished) { // TAP
                    await handleBoardClick();
                    resetTttGame();
                 }
            }
            state.isDragging = false;
        }

        function handleDoubleTap() {
            if (state.settings.tttMode === 'online') {
                resetTttGame();
                return;
            }
            if (state.gameFinished || state.settings.tttMode !== 'manual') return;
            const middleCell = 4;
            if (state.boardData[middleCell] === null) {
                state.boardData[middleCell] = state.currentPlayer;
                handlePostMove();
            }
        }

        async function handleBoardClick() {
            if (!state.gameFinished) return;
            const isSuccess = await copyBase64ToClipboard(dom.boardImage);
            if (isSuccess && state.settings.tttShortcutName) {
                window.location.href = `shortcuts://run-shortcut?name=${encodeURIComponent(state.settings.tttShortcutName)}`;
            }
        }
        
        function toggleTttShortcutInputMode(newMode, isInitialLoad = false) {
            state.settings.tttShortcutInputMode = newMode;
            if (!isInitialLoad) resetTttGame();

            const isAuto = newMode === 'auto';
            dom.shortcutModeAutoBtn.classList.toggle(CLASS_NAMES.ACTIVE_BUTTON, isAuto);
            dom.shortcutModeAutoBtn.classList.toggle(CLASS_NAMES.INACTIVE_BUTTON, !isAuto);
            dom.shortcutModeSwipeBtn.classList.toggle(CLASS_NAMES.ACTIVE_BUTTON, !isAuto);
            dom.shortcutModeSwipeBtn.classList.toggle(CLASS_NAMES.INACTIVE_BUTTON, isAuto);

            if (isAuto) {
                initializeTttFirebaseListener();
            } else { // swipe
                if (state.firebaseUnsubscribe) {
                    state.firebaseUnsubscribe();
                    state.firebaseUnsubscribe = null;
                }
            }
        }
        
        function toggleTttMode(newMode, isInitialLoad = false) {
            state.settings.tttMode = newMode;
            if (!isInitialLoad) resetTttGame();

            const isDirectShortcut = newMode === 'directShortcut';

            dom.shortcutInputModeContainer.classList.toggle(CLASS_NAMES.HIDDEN, !isDirectShortcut);
            dom.tttGame.classList.toggle(CLASS_NAMES.HIDDEN, isDirectShortcut);
            dom.directShortcutModeDisplay.classList.toggle(CLASS_NAMES.HIDDEN, !isDirectShortcut);
            dom.tttTextSettingsContainer.classList.toggle(CLASS_NAMES.HIDDEN, isDirectShortcut);

            if (newMode === 'online') {
                initializeTttFirebaseListener();
            } else if (isDirectShortcut) {
                toggleTttShortcutInputMode(state.settings.tttShortcutInputMode, true);
            } else { // manual
                if (state.firebaseUnsubscribe) {
                    state.firebaseUnsubscribe();
                    state.firebaseUnsubscribe = null;
                }
            }

            dom.modeOnlineBtn.classList.toggle(CLASS_NAMES.ACTIVE_BUTTON, newMode === 'online');
            dom.modeOnlineBtn.classList.toggle(CLASS_NAMES.INACTIVE_BUTTON, newMode !== 'online');
            dom.modeManualBtn.classList.toggle(CLASS_NAMES.ACTIVE_BUTTON, newMode === 'manual');
            dom.modeManualBtn.classList.toggle(CLASS_NAMES.INACTIVE_BUTTON, newMode !== 'manual');
            dom.modeDirectShortcutBtn.classList.toggle(CLASS_NAMES.ACTIVE_BUTTON, isDirectShortcut);
            dom.modeDirectShortcutBtn.classList.toggle(CLASS_NAMES.INACTIVE_BUTTON, !isDirectShortcut);
        }

        function initializeTttFirebaseListener() {
            if (state.firebaseUnsubscribe) state.firebaseUnsubscribe();
            const gameRef = ref(db, 'magic-game-state');
            state.firebaseUnsubscribe = onValue(gameRef, (snapshot) => {
                if (!snapshot.exists()) return;
                const gameState = snapshot.val();
                if (!gameState || !gameState.board) return;
                
                const wasFinished = state.gameFinished;
                for (let i = 0; i < 9; i++) state.boardData[i] = gameState.board[i] || null;
                const winnerInfo = checkWinner(state.boardData);
                const isFull = state.boardData.every(cell => cell !== null);
                const isGameOver = !!winnerInfo || isFull;

                if (state.settings.tttMode === 'directShortcut') {
                    if (isGameOver) {
                        if (wasFinished) return;
                        state.gameFinished = true;
                        drawOnCanvas(outputCanvas, state.boardData, winnerInfo ? winnerInfo.combination : null);
                        dom.boardImage.src = outputCanvas.toDataURL('image/png');
                        dom.directShortcutStatusText.textContent = 'Data ready. Tap to run shortcut.';
                    } else {
                        state.gameFinished = false; 
                        dom.directShortcutStatusText.textContent = 'Waiting for game data...';
                    }
                } else { // online mode
                    if (wasFinished) return;
                    drawOnCanvas(dom.peekCanvas, state.boardData, winnerInfo ? winnerInfo.combination : null); 
                    if (isGameOver) handlePostMove();
                }
            });
        }
        
        // --- ROCK-PAPER-SCISSORS LOGIC ---
        function initRockPaperScissors(isInitialLoad) { /* ... existing code ... */ }
        function resetRpsGame() { /* ... existing code ... */ }
        function generateRpsPlan() { /* ... existing code ... */ }
        function initializeRpsFirebaseListener() { /* ... existing code ... */ }
        function handleRpsMagic(opponentChoice) { /* ... existing code ... */ }
        function handleSpectatorChoice(chosen) { /* ... existing code ... */ }
        function showRpsFullscreen(src) { /* ... existing code ... */ }
        function closeRpsFullscreen() { /* ... existing code ... */ }
        function toggleRpsPlayMode(newMode, isInitialLoad = false) { /* ... existing code ... */ }

        // --- SETTINGS & STORAGE ---
        function openSettings() { dom.settingsPanel.classList.remove(CLASS_NAMES.HIDDEN); }
        function closeSettings() { dom.settingsPanel.classList.add(CLASS_NAMES.HIDDEN); }
        
        function updatePredictionTextUI() {
            if (state.settings.tttMode !== 'directShortcut') {
                dom.predictionTextDisplay.textContent = state.settings.tttPredictionText;
            }
        }

        function saveSettings() {
            state.settings.gameMode = dom.gameModeSelect.value;
            state.settings.tttShortcutName = dom.shortcutNameInput.value.trim();
            state.settings.tttPredictionText = dom.predictionTextInput.value.trim() || 'my prediction..';
            state.settings.tttWinnerResultText = dom.winnerResultTextInput.value.trim() || 'I knew... $winner would win!';
            state.settings.tttDrawText = dom.drawResultTextInput.value.trim() || 'I knew... it would be a draw!';
            let rounds = parseInt(dom.rpsRoundsInput.value) || 1;
            let wins = parseInt(dom.rpsWinsInput.value) || 0;
            let loses = parseInt(dom.rpsLosesInput.value) || 0;
            let draws = parseInt(dom.rpsDrawsInput.value) || 0;

            if (state.settings.rpsPlayMode !== 'mirroring' && (wins + loses + draws > rounds)) {
                alert("The sum of target Wins, Losses, & Draws cannot exceed the Number of Rounds."); return;
            }
            state.settings.rpsRounds = rounds; state.settings.rpsWins = wins; state.settings.rpsLoses = loses; state.settings.rpsDraws = draws;
            dom.rpsRoundsInput.value = rounds; dom.rpsWinsInput.value = wins; dom.rpsLosesInput.value = loses; dom.rpsDrawsInput.value = draws;

            localStorage.setItem('playerZeroSettings', JSON.stringify(state.settings));
            closeSettings();
            switchGameMode(state.settings.gameMode);
        }
        function loadSettings() {
            const saved = localStorage.getItem('playerZeroSettings');
            if (saved) {
                const defaults = { 
                    gameMode: 'TicTacToe', tttMode: 'online', tttShortcutInputMode: 'auto', tttShortcutName: '', 
                    tttPredictionText: 'my prediction..', 
                    tttWinnerResultText: 'I knew... $winner would win!',
                    tttDrawText: 'I knew... it would be a draw!',
                    rpsPlayMode: 'magicianFirst', rpsRounds: 5, rpsWins: 0, rpsLoses: 0, rpsDraws: 0 
                };
                state.settings = { ...defaults, ...JSON.parse(saved) };
            }
            dom.gameModeSelect.value = state.settings.gameMode;
            dom.shortcutNameInput.value = state.settings.tttShortcutName || '';
            dom.predictionTextInput.value = state.settings.tttPredictionText;
            dom.winnerResultTextInput.value = state.settings.tttWinnerResultText;
            dom.drawResultTextInput.value = state.settings.tttDrawText;
            dom.rpsRoundsInput.value = state.settings.rpsRounds; 
            dom.rpsWinsInput.value = state.settings.rpsWins;
            dom.rpsLosesInput.value = state.settings.rpsLoses; 
            dom.rpsDrawsInput.value = state.settings.rpsDraws;
            
            const isTTT = state.settings.gameMode === 'TicTacToe';
            dom.tttSettings.classList.toggle(CLASS_NAMES.HIDDEN, !isTTT);
            dom.rpsSettings.classList.toggle(CLASS_NAMES.HIDDEN, isTTT);
            switchGameMode(state.settings.gameMode, true);
        }
        
        // --- PWA & Initialization ---
        function registerServiceWorker() { /* ... existing code ... */ }
        function showUpdateNotification() { /* ... existing code ... */ }
        function listenForServiceWorkerUpdates() { /* ... existing code ... */ }
        function setupEventListeners() {
            dom.sliderStage.addEventListener('touchstart', handleTouchStart, { passive: false });
            dom.sliderStage.addEventListener('touchmove', handleTouchMove, { passive: false });
            dom.sliderStage.addEventListener('touchend', handleTouchEnd);
            
            dom.directShortcutModeDisplay.addEventListener('touchstart', handleTouchStart, { passive: false });
            dom.directShortcutModeDisplay.addEventListener('touchmove', handleTouchMove, { passive: false });
            dom.directShortcutModeDisplay.addEventListener('touchend', handleTouchEnd);


            window.addEventListener('resize', debounce(updateSlideDimensions, 250));
            
            dom.settingsTrigger.addEventListener('click', openSettings);
            dom.closeSettingsBtn.addEventListener('click', closeSettings);
            dom.saveSettingsBtn.addEventListener('click', saveSettings);
            dom.gameModeSelect.addEventListener('change', (e) => {
                switchGameMode(e.target.value);
            });
            dom.modeOnlineBtn.addEventListener('click', () => toggleTttMode('online'));
            dom.modeManualBtn.addEventListener('click', () => toggleTttMode('manual'));
            dom.modeDirectShortcutBtn.addEventListener('click', () => toggleTttMode('directShortcut'));
            dom.shortcutModeAutoBtn.addEventListener('click', () => toggleTttShortcutInputMode('auto'));
            dom.shortcutModeSwipeBtn.addEventListener('click', () => toggleTttShortcutInputMode('swipe'));

            dom.rpsModeMagicianBtn.addEventListener('click', () => toggleRpsPlayMode('magicianFirst'));
            dom.rpsModeSpectatorBtn.addEventListener('click', () => toggleRpsPlayMode('spectatorFirst'));
            dom.rpsModeMirroringBtn.addEventListener('click', () => toggleRpsPlayMode('mirroring'));
            dom.rockWrapper.addEventListener('click', () => handleSpectatorChoice('rock'));
            dom.paperWrapper.addEventListener('click', () => handleSpectatorChoice('paper'));
            dom.scissorsWrapper.addEventListener('click', () => handleSpectatorChoice('scissors'));
            dom.rpsCloseFullscreenBtn.addEventListener('click', closeRpsFullscreen);

            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeSettings(); });
        }
        
        function init() {
            onAuthStateChanged(auth, user => { if (!user) signInAnonymously(auth); });
            loadSettings();
            setupEventListeners();
            registerServiceWorker();
            listenForServiceWorkerUpdates();
        }
        init();
    </script>
</body>
</html>
