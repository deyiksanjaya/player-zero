<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Player Zero by Heri Sanjaya</title>
    <meta name="theme-color" content="#000000"/>
    <link rel="manifest" href="./manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Player Zero">
    <link rel="apple-touch-icon" href="images/icons/icon-180x180.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Poppins', sans-serif;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #000000;
        }
        .main-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #board-image {
            width: 100%;
            height: 100%;
            max-width: 100vh;
            max-height: 100vh;
            background-color: #ffffff;
            box-shadow: 0 4px 25px rgba(255,255,255,0.1);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.15s ease-out;
        }
        #board-image:active { transform: scale(0.97); }

        /* settings trigger should always be clickable above everything */
        #settings-trigger {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 56px;
            height: 56px;
            z-index: 9999; /* very high so it's always clickable */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            background: rgba(255,255,255,0.03);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            cursor: pointer;
        }
        #settings-trigger:active { transform: scale(0.98); }

        #settings-panel { z-index: 10000; }

        #notification {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        #manual-grid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 6px;
        }
        .manual-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 2.5em;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .manual-cell:active { background-color: rgba(255, 255, 255, 0.2); }
    </style>
</head>
<body class="flex items-center justify-center h-screen">

    <!-- Settings trigger (always clickable) -->
    <div id="settings-trigger" title="Settings">
        <!-- simple gear icon (SVG) -->
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z" stroke="#fff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06A2 2 0 1 1 4.28 16.88l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 1 1 7.71 4.28l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 11.5 4V3a2 2 0 1 1 4 0v.09c.2.06.39.15.56.26.2.12.39.25.56.4l.54.48a1.65 1.65 0 0 0 1.33.4h.01a2 2 0 1 1 0 4h-.09c-.7 0-1.28.39-1.51 1z" stroke="#fff" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

    <div id="settings-panel" class="hidden absolute inset-0 bg-black/60 backdrop-blur-md flex items-center justify-center p-4">
        <div class="bg-gray-800 border border-gray-700 text-white rounded-xl shadow-lg w-full max-w-sm p-6 space-y-4">
            <h2 class="text-xl font-bold mb-4">Settings</h2>
            <div>
                <label class="font-medium">Input Mode</label>
                <div class="mt-2 grid grid-cols-2 gap-2">
                    <button id="mode-online-btn" class="p-2 rounded-md">Online</button>
                    <button id="mode-manual-btn" class="p-2 rounded-md">Manual</button>
                </div>
            </div>
            <div id="manual-position-setting" class="hidden">
                <label class="font-medium">Manual Grid Position</label>
                <div class="mt-2 grid grid-cols-2 gap-2">
                    <button id="pos-left-btn" class="p-2 rounded-md">Left</button>
                    <button id="pos-right-btn" class="p-2 rounded-md">Right</button>
                </div>
            </div>
            <div>
                <label for="shortcut-name" class="font-medium">Shortcut Name</label>
                <input type="text" id="shortcut-name" placeholder="Your Shortcut Name" class="w-full p-2 mt-1 bg-gray-700 border border-gray-600 rounded-md focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="mt-6 flex justify-end">
                <button id="save-settings-btn" class="px-5 py-2 bg-blue-600 font-semibold rounded-lg hover:bg-blue-700">Close</button>
            </div>
        </div>
    </div>

    <div id="main-container" class="main-container">
        <img id="board-image" src="" alt="Game Board">
    </div>

    <div id="manual-input-container" class="hidden fixed inset-0 z-30 flex items-center p-6 text-white">
        <div id="manual-grid"></div>
        <div id="swipe-instruction" class="absolute bottom-10 left-1/2 -translate-x-1/2 text-gray-400 text-sm text-center"></div>
    </div>

    <div id="notification" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-200 text-black px-6 py-3 rounded-full shadow-lg text-sm font-medium z-50"></div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js';
        import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js';

        // === EDIT: Replace with your Firebase config ===
        const firebaseConfig = {
          apiKey: "AIzaSyDsnZdGtP-tY1_vstQOidbM3tS-UktY45Y",
          authDomain: "player-zer0.firebaseapp.com",
            databaseURL: "https://player-zer0-default-rtdb.asia-southeast1.firebasedatabase.app", 
          projectId: "player-zer0",
          storageBucket: "player-zer0.firebasestorage.app",
          messagingSenderId: "1009636905003",
          appId: "1:1009636905003:web:f3fafd5f5a693440769a6e"
        };
        // ==============================================

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        let gameRef = ref(db, 'magic-game-state');
        let unsubscribeFirebase;

        // Elements
        const boardImage = document.getElementById('board-image');
        const mainContainer = document.getElementById('main-container');
        const settingsTrigger = document.getElementById('settings-trigger');
        const settingsPanel = document.getElementById('settings-panel');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const shortcutNameInput = document.getElementById('shortcut-name');
        const notification = document.getElementById('notification');

        // Manual Mode Elements
        const manualInputContainer = document.getElementById('manual-input-container');
        const manualGrid = document.getElementById('manual-grid');
        const manualPositionSetting = document.getElementById('manual-position-setting');
        const modeOnlineBtn = document.getElementById('mode-online-btn');
        const modeManualBtn = document.getElementById('mode-manual-btn');
        const posLeftBtn = document.getElementById('pos-left-btn');
        const posRightBtn = document.getElementById('pos-right-btn');
        const swipeInstruction = document.getElementById('swipe-instruction');

        // Two canvases: one for preview (display) and one for export (clipboard)
        const previewCanvas = document.createElement('canvas');
        const exportCanvas = document.createElement('canvas');

        let settings = {
            shortcutName: '',
            imageFormat: 'square',
            mode: 'online',
            manualPos: 'left'
        };

        let latestBoardData = Array(9).fill(null);
        let manualBoardData = Array(9).fill(null);
        let manualCurrentPlayer = 'X';
        let manualMoveHistory = [];

        const winningCombinations = [
            [0,1,2],[3,4,5],[6,7,8],
            [0,3,6],[1,4,7],[2,5,8],
            [0,4,8],[2,4,6]
        ];

        // --- Swipe Detection ---
        let touchStartX = 0, touchEndX = 0, touchStartY = 0, touchEndY = 0;

        document.addEventListener('touchstart', e => {
            // if settings panel is open, ignore manual gestures so settings is usable
            if (settingsPanel && !settingsPanel.classList.contains('hidden')) return;
            if (settings.mode !== 'manual' || manualInputContainer.classList.contains('hidden')) return;
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', e => {
            if (settingsPanel && !settingsPanel.classList.contains('hidden')) return;
            if (settings.mode !== 'manual' || manualInputContainer.classList.contains('hidden')) return;
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        });

        function handleSwipe(){
            const swipeThreshold = 50;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > swipeThreshold){
                // swipe down = undo
                if (manualMoveHistory.length > 0){
                    const last = manualMoveHistory.pop();
                    manualBoardData[last] = null;
                    manualCurrentPlayer = (manualCurrentPlayer === 'X')? 'O' : 'X';
                    renderManualGrid();
                    showNotification('Last move undone.');
                }
                return;
            }
            let confirmed = false;
            if (settings.manualPos === 'left' && deltaX > swipeThreshold) confirmed = true;
            if (settings.manualPos === 'right' && deltaX < -swipeThreshold) confirmed = true;
            if (confirmed) submitManualBoard('Manual board confirmed!');
        }

        function checkWinner(board){
            for (const c of winningCombinations){
                const [a,b,cidx] = c; // avoid shadowing, but we won't use cidx
            }
            for (const comb of winningCombinations){
                const [a,b,cidx] = comb;
                if (board[a] && board[a] === board[b] && board[a] === board[cidx]) return board[a];
            }
            return null;
        }

        function isBoardFull(board){
            return board.every(cell => cell !== null);
        }

        // --- Display preview (kept square, unmodified) ---
        function renderDisplayBoard(boardData){
            const size = 512;
            previewCanvas.width = size;
            previewCanvas.height = size;
            const ctx = previewCanvas.getContext('2d');

            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,size,size);

            // grid
            ctx.strokeStyle = '#CBD5E1';
            ctx.lineWidth = 6;
            ctx.beginPath();
            for (let i=1;i<3;i++){
                ctx.moveTo(i*size/3,0); ctx.lineTo(i*size/3,size);
                ctx.moveTo(0,i*size/3); ctx.lineTo(size,i*size/3);
            }
            ctx.stroke();

            // marks
            ctx.font = `bold ${Math.floor(size/3 * 0.7)}px Poppins`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            boardData.forEach((v, idx) =>{
                if (!v) return;
                const row = Math.floor(idx/3), col = idx%3;
                const x = col*size/3 + size/6;
                const y = row*size/3 + size/6;
                ctx.fillStyle = v === 'X' ? '#EF4444' : '#3B82F6';
                ctx.fillText(v, x, y);
            });

            // set preview image (does not affect export)
            boardImage.src = previewCanvas.toDataURL('image/png');
        }

        // --- Export for clipboard: 420x910, white bg, board centered ---
        function generateExportImage(boardData){
            const W = 420, H = 910;
            exportCanvas.width = W;
            exportCanvas.height = H;
            const ctx = exportCanvas.getContext('2d');

            // white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,W,H);

            // compute board size and center it
            const padding = 20;
            const maxBoardW = W - padding*2; // 380
            // choose board height fraction so it looks centered vertically
            const boardSize = Math.min(maxBoardW, Math.floor(H * 0.42)); // ~380
            const startX = Math.round((W - boardSize)/2);
            const startY = Math.round((H - boardSize)/2);

            // draw board background (white already) then grid
            const cellSize = boardSize / 3;
            const lineThickness = Math.max(4, Math.round(boardSize * 0.012));
            ctx.strokeStyle = '#CBD5E1';
            ctx.lineWidth = lineThickness;
            ctx.beginPath();
            for (let i=1;i<3;i++){
                ctx.moveTo(startX + i*cellSize, startY);
                ctx.lineTo(startX + i*cellSize, startY + boardSize);
                ctx.moveTo(startX, startY + i*cellSize);
                ctx.lineTo(startX + boardSize, startY + i*cellSize);
            }
            ctx.stroke();

            // draw marks
            ctx.font = `bold ${Math.floor(cellSize * 0.7)}px Poppins`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            boardData.forEach((v, idx) =>{
                if (!v) return;
                const row = Math.floor(idx/3), col = idx%3;
                const x = startX + col*cellSize + cellSize/2;
                const y = startY + row*cellSize + cellSize/2;
                ctx.fillStyle = v === 'X' ? '#EF4444' : '#3B82F6';
                ctx.fillText(v, x, y);
            });

            return exportCanvas;
        }

        // copy export canvas as image to clipboard (best-effort)
        async function copyExportToClipboard(boardData){
            const c = generateExportImage(boardData);
            try{
                const blob = await new Promise(resolve => c.toBlob(resolve, 'image/png'));
                const item = new ClipboardItem({ 'image/png': blob });
                await navigator.clipboard.write([item]);
                return true;
            }catch(e){
                // fallback: copy dataURL as text (some platforms)
                try{
                    const dataUrl = c.toDataURL('image/png');
                    await navigator.clipboard.writeText(dataUrl);
                    return true;
                }catch(err){
                    console.error('Clipboard write failed', err);
                    return false;
                }
            }
        }

        function submitManualBoard(message){
            latestBoardData = [...manualBoardData];
            renderDisplayBoard(latestBoardData);
            mainContainer.classList.remove('hidden');
            manualInputContainer.classList.add('hidden');
            showNotification(message);
        }

        function renderManualGrid(){
            manualGrid.innerHTML = '';
            for (let i=0;i<9;i++){
                const cell = document.createElement('div');
                cell.className = 'manual-cell';
                cell.textContent = manualBoardData[i] || '';
                cell.addEventListener('click', () =>{
                    if (manualBoardData[i] !== null) return;
                    manualMoveHistory.push(i);
                    manualBoardData[i] = manualCurrentPlayer;
                    cell.textContent = manualCurrentPlayer;
                    const winner = checkWinner(manualBoardData);
                    const full = isBoardFull(manualBoardData);
                    if (winner || full){
                        const msg = winner ? `Winner is ${winner}! Board confirmed.` : 'Board is full! Board confirmed.';
                        submitManualBoard(msg);
                        return;
                    }
                    manualCurrentPlayer = (manualCurrentPlayer === 'X')? 'O' : 'X';
                });
                manualGrid.appendChild(cell);
            }
        }

        function toggleMode(newMode){
            settings.mode = newMode;
            if (newMode === 'online'){
                mainContainer.classList.remove('hidden');
                manualInputContainer.classList.add('hidden');
                initializeFirebaseListener();
            }else{
                mainContainer.classList.add('hidden');
                manualInputContainer.classList.remove('hidden');
                manualBoardData = Array(9).fill(null);
                manualMoveHistory = [];
                manualCurrentPlayer = 'X';
                renderManualGrid();
                if (unsubscribeFirebase){ unsubscribeFirebase(); unsubscribeFirebase = null; }
            }
            updateSettingsUI();
        }

        function updateSettingsUI(){
            modeOnlineBtn.style.backgroundColor = settings.mode === 'online' ? '#3b82f6' : 'rgba(255,255,255,0.1)';
            modeManualBtn.style.backgroundColor = settings.mode === 'manual' ? '#3b82f6' : 'rgba(255,255,255,0.1)';
            posLeftBtn.style.backgroundColor = settings.manualPos === 'left' ? '#3b82f6' : 'rgba(255,255,255,0.1)';
            posRightBtn.style.backgroundColor = settings.manualPos === 'right' ? '#3b82f6' : 'rgba(255,255,255,0.1)';
            manualPositionSetting.style.display = settings.mode === 'manual' ? 'block' : 'none';
            manualInputContainer.style.justifyContent = settings.manualPos === 'left' ? 'flex-start' : 'flex-end';
            swipeInstruction.innerHTML = (settings.manualPos === 'left' ? 'Swipe right: Confirm' : 'Swipe left: Confirm') + '<br>Swipe down: Undo';
            shortcutNameInput.value = settings.shortcutName || '';
        }

        function showNotification(msg){
            notification.textContent = msg;
            notification.classList.remove('hidden','opacity-0');
            notification.classList.add('opacity-100');
            setTimeout(()=>{ notification.classList.add('opacity-0'); setTimeout(()=>notification.classList.add('hidden'),300); }, 2200);
        }

        // --- Board tap (copy export image) ---
        async function handleBoardTap(){
            if (!settings.shortcutName){
                showNotification('Please set a Shortcut Name.');
                setTimeout(()=>{ openSettings(); shortcutNameInput.focus(); }, 400);
                return;
            }
            const ok = await copyExportToClipboard(latestBoardData);
            if (ok) showNotification('Image copied (420×910) to clipboard');
            else showNotification('Failed to copy image');
            // optionally try run shortcut
            setTimeout(()=>{
                try{ const encoded = encodeURIComponent(settings.shortcutName); window.location.href = `shortcuts://run-shortcut?name=${encoded}`; }catch(e){}
            }, 500);
        }

        function saveSettings(){
            settings.shortcutName = shortcutNameInput.value.trim();
            localStorage.setItem('appSettings', JSON.stringify(settings));
            settingsPanel.classList.add('hidden');
            toggleMode(settings.mode);
        }

        function loadSettings(){
            const s = JSON.parse(localStorage.getItem('appSettings') || '{}');
            settings = { ...settings, ...s };
            shortcutNameInput.value = settings.shortcutName || '';
            toggleMode(settings.mode);
        }

        function initializeFirebaseListener(){
            if (unsubscribeFirebase) unsubscribeFirebase();
            if (settings.mode !== 'online') return;
            unsubscribeFirebase = onValue(gameRef, snapshot =>{
                const finalBoard = Array(9).fill(null);
                if (snapshot.exists()){
                    const gameState = snapshot.val();
                    if (gameState && gameState.board){
                        const received = gameState.board;
                        for (const k in received){
                            const val = received[k];
                            const idx = parseInt(k,10);
                            if (!isNaN(idx) && idx>=0 && idx<9) finalBoard[idx] = val;
                        }
                    }
                }
                latestBoardData = [...finalBoard];
                renderDisplayBoard(latestBoardData);
            });
        }

        // Settings open/close helpers
        function openSettings(){ settingsPanel.classList.remove('hidden'); updateSettingsUI(); }
        function closeSettings(){ settingsPanel.classList.add('hidden'); }

        // --- Event listeners ---
        settingsTrigger.addEventListener('click', (e)=>{ e.stopPropagation(); openSettings(); });
        settingsPanel.addEventListener('click', (e)=>{ if (e.target === settingsPanel) closeSettings(); });
        saveSettingsBtn.addEventListener('click', saveSettings);

        modeOnlineBtn.addEventListener('click', ()=>{ settings.mode = 'online'; updateSettingsUI(); });
        modeManualBtn.addEventListener('click', ()=>{ settings.mode = 'manual'; updateSettingsUI(); });
        posLeftBtn.addEventListener('click', ()=>{ settings.manualPos = 'left'; updateSettingsUI(); });
        posRightBtn.addEventListener('click', ()=>{ settings.manualPos = 'right'; updateSettingsUI(); });

        boardImage.addEventListener('click', handleBoardTap);

        loadSettings();
    </script>

    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => { navigator.serviceWorker.register('./service-worker.js'); });
      }
    </script>
</body>
</html>
